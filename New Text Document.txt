FileSystem

FileSystem: The name of the data type, which can represent either a file or a root directory.

Constructors:

File String String:
Represents a file with two String attributes:
The first String could be the file name.
The second String could be the file contents or some other metadata about the file.
Root String [FileSystem]:
Represents a root directory with:
A String (e.g., the directory name or some metadata about the directory).
A list of FileSystem elements ([FileSystem]) representing the files and/or subdirectories contained within this directory.
This tells Haskell to automatically generate an instance of the Show typeclass for the FileSystem type. As a result, values of type FileSystem can be converted to a string for display, typically for debugging or printing.

File "hello.txt" "Hello, world!"
Root "root" [File "file1.txt" "Content1", File "file2.txt" "Content2"]



Stack

headStack
Type Signature:
[a] is a list of elements of any type a.
Returns Maybe a, which indicates that the function might return a value (Just x) or nothing (Nothing).
Functionality:
If the list is non-empty (x : xs), return Just x, where x is the first element (head of the list).
If the list is empty (_), return Nothing.

pushStack

Explanation:
Type Signature:
Takes an element el of type a and a list (st of type [a]).
Returns a new list [a] with the element added.
Functionality:
Appends the element el to the end of the list st.
st ++ [el] means concatenate the list st with the list containing only el.

popStack
Explanation:
Type Signature:
Takes a list [a] and returns a new list [a].
Functionality:
If the list contains a single element ([x]), return an empty list.
If the list has more elements (x : xs), recursively call popStack on the rest of the list (xs) and prepend x to the result.

popStack :: [a] -> [a]
popStack [] = []
popStack xs = init xs


topStack
Explanation:
Type Signature:
Takes a list [a] and returns an element a.
Functionality:
If the list has a single element ([x]), return that element.
If the list has more elements (x : xs), recursively call topStack on the rest of the list (xs).


topStack :: [a] -> a
topStack [] = error "Empty stack"
topStack xs = last xs


Predicates

isNameFolder
Explanation:
Type Signature:
Takes a String (a name) and a FileSystem (a folder or file).
Returns a Bool indicating whether the given name matches the name of a folder.
Functionality:
If the FileSystem is a Root (a folder), check if its name (name2) matches the given name (name1).
For other types of FileSystem (e.g., File), return False.

isNameFile
Type Signature:
Takes a String (a name) and a FileSystem (a folder or file).
Returns a Bool indicating whether the given name matches the name of a file.
Functionality:
If the FileSystem is a File, check if its name (name2) matches the given name (name1).
For other types of FileSystem (e.g., Root), return False.

isFilePath
Type Signature:
Takes a String (a potential file path).
Returns a Bool indicating whether the string is a valid file path.
Functionality:
A string is considered a file path if it starts with a /.
If the string does not start with /, it is not a valid file path.

isValidName
Explanation:
Type Signature:
Takes a function f of type (String -> FileSystem -> Bool), a String (name), and a FileSystem.
Returns a Bool indicating whether the name is valid.
Functionality:
If the FileSystem is a Root (a folder):
Check that the folder's name (name2) is not equal to the given name (name1).
Check recursively whether any child FileSystem in the folder (xs) satisfies the condition defined by f.
Use foldr to iterate through the list of child FileSystem elements (xs), applying f to each child and combining results with || (logical OR).
For other types of FileSystem, return True.
Purpose:
This function generalizes the validation of names. The function f passed as an argument defines the validation rule.
Example of f:
isNameFile checks if a name matches any file in the structure.
isNameFolder checks if a name matches any folder in the structure.
Example:
Consider the following FileSystem:


fs = Root "root" [File "file1" "content", Root "subdir" [File "file2" "data"]]
isValidName isNameFile "file1" fs:
The folder name "root" is not "file1".
The fold operation checks:
isNameFile "file1" (File "file1" "content") → True
isNameFile "file1" (Root "subdir" [File "file2" "data"]) → False
Result: True (because "file1" exists in the structure).





Parser



Parser Type:

haskell
Копиране на код
newtype Parser prs = Parser {runParser :: String -> Maybe (String, prs)}
Parser prs is a wrapper around a function String -> Maybe (String, prs).
The parser takes an input String and produces a Maybe result.
Nothing if the parse fails.
Just (remainingString, parsedValue) on success.


Functor Instance:

haskell
Копиране на код
instance Functor Parser where
    fmap f (Parser p) = Parser $ \input -> do
         (input1, x) <- p input
         Just (input1, f x)
Implements fmap to transform the result (prs) of a parser while keeping the structure intact.
Uses a monadic bind (do) to apply f to the parsed result.


Applicative Instance:

haskell
Копиране на код
instance Applicative Parser where
    pure x = Parser $ \x1 -> Just (x1, x)
    (Parser p) <*> (Parser p1) =
        Parser $ \x -> do
        (x1, f) <- p x
        (x2, a) <- p1 x1
        Just (x2, f a)
pure wraps a value x into a parser that always succeeds without consuming input.
<*> combines two parsers:
The first parser produces a function f.
The second parser produces a value a.
Applies f to a.


Alternative Instance:

haskell
Копиране на код
instance Alternative Parser where
    empty = Parser $ const Nothing
    (Parser p) <|> (Parser p1) = Parser $ \x -> p x <|> p1 x
empty is a parser that always fails.
<|> tries the first parser, and if it fails, tries the second parser.

Basic Parsers
charParser:

haskell
Копиране на код
charParser :: Char -> Parser Char
charParser x = Parser foo
 where
     foo [] = Nothing
     foo (y : ys)
      | y == x = Just (ys, x)
      | otherwise = Nothing
Parses a single character x from the input string.
stringParser:

haskell
Копиране на код
stringParser :: String -> Parser String
stringParser = traverse charParser
Parses a specific sequence of characters (string) by combining multiple charParsers using traverse.
spanParser:

haskell
Копиране на код
spanParser :: (Char -> Bool) -> Parser String
spanParser f = Parser $ \input -> let (token, rest) = span f input in Just (rest, token)
Parses a span of characters as long as they satisfy the predicate f.
Whitespace Parser (ws):

haskell
Копиране на код
ws :: Parser String 
ws = spanParser isSpace
Parses and consumes all whitespace characters.
Command Parsers
slashParser:

haskell
Копиране на код
slashParser :: Parser String
slashParser = charParser '/' *> spanParser (/='/')
Parses a / followed by a span of non-/ characters.
getNextDir:

haskell
Копиране на код
getNextDir :: String -> Maybe (String, String)
getNextDir "" = Just ("", "")
getNextDir x = runParser slashParser x
Extracts the next directory name after a / from the input.
Command Parsers: These parsers match specific commands like cd, pwd, ls, etc.:

haskell
Копиране на код
cdParser :: Parser String
cdParser = stringParser "cd"
Parses the command cd and similar ones.
cmdParser:

haskell
Копиране на код
cmdParser :: Parser String 
cmdParser = cdParser <|> pwdParser <|> lsParser <|> catParser <|> rmParser <|> quitParser <|> dirParser <|> showParser
Combines all command parsers using <|> to parse any of the defined commands.
Utility Parsers
wordParser:

haskell
Копиране на код
wordParser :: String -> Maybe (String, String)
wordParser = runParser $ spanParser (/= ' ') <* ws
Parses a single word (non-space characters) and consumes trailing whitespace.
eofParser:

haskell
Копиране на код
eofParser :: String -> Maybe (String, String) 
eofParser = runParser $ spanParser (/= '~') <* charParser '~' <* ws
Parses until encountering ~, consumes it, and skips trailing whitespace.
parseCmd:

haskell
Копиране на код
parseCmd :: String -> Maybe (String, String)
parseCmd = runParser (cmdParser <* ws)
Parses a command followed by optional whitespace.

Usage Example
To parse the command cd:

haskell
Копиране на код
parseCmd "cd /home"
-- Output: Just ("/home", "cd")
To parse directories with getNextDir:

haskell
Копиране на код
getNextDir "/home/user"
-- Output: Just ("/user", "home")

Finders

1. findFile
haskell
Копиране на код
findFile :: String -> [FileSystem] -> Maybe FileSystem
findFile name xs = 
    case filter (isNameFile name) xs of 
        [] -> Nothing
        (x : _) -> Just x
Purpose: Finds a file by its name in a list of FileSystem items.
Logic:
Filters the list xs to find items where isNameFile name returns True.
If no matching file is found ([]), return Nothing.
If a match is found, return the first matching item wrapped in Just.

2. findFolder
haskell
Копиране на код
findFolder :: String -> FileSystem -> Maybe FileSystem
findFolder name (Root _ xs) = 
    case filter (isNameFolder name) xs of 
        [] -> Nothing
        (x : _) -> Just x
findFolder _ _ = Nothing
Purpose: Finds a folder by its name within a Root node of the file system.
Logic:
Operates only on Root nodes.
Filters the contents of the Root for items matching the folder name using isNameFolder.
Returns Nothing if no match is found; otherwise, returns the first match wrapped in Just.

3. findFileInRoot
haskell
Копиране на код
findFileInRoot :: String -> FileSystem -> Maybe FileSystem
findFileInRoot name (Root _ xs) = findFile name xs
findFileInRoot _ _ = Nothing
Purpose: A convenience function to find a file by its name directly in the root directory of the file system.
Logic:
Calls findFile on the contents of the Root.
Returns Nothing if the input is not a Root.

4. findFileByDir
haskell
Копиране на код
findFileByDir :: String -> FileSystem -> Maybe FileSystem
findFileByDir input x@(Root _ xs) = 
    case getNextDir input of
        Just ("", file) -> findFile file xs
        Just (rest, curr) -> case findFolder curr x of 
            Nothing -> Nothing 
            Just cFolder -> findFileByDir rest cFolder
findFileByDir _ _ = Nothing
Purpose: Finds a file within a nested directory structure based on a path string.
Logic:
getNextDir: Splits the input path into the current directory/file (curr) and the rest of the path (rest).
If the path is empty ("") and a file name is provided (file), it tries to find the file in the root directory using findFile.
Recursive Search:
If curr is a folder:
Use findFolder to locate it.
Recurse into the folder with the remaining path (rest) using findFileByDir.
If any step fails (Nothing), the function stops and returns Nothing.


Others

1. listMaybe:
haskell
Копиране на код
listMaybe :: [Maybe a] -> Maybe [a]
listMaybe [] = Just []
listMaybe ((Just x) : xs) = 
    case listMaybe xs of 
        (Just res) -> Just (x : res)
        Nothing -> Nothing
listMaybe (Nothing : xs) = listMaybe xs
Purpose:
This function takes a list of Maybe a (a list of optional values) and attempts to combine them into a single Maybe [a] (a list of values wrapped in Maybe).
Logic:
Base Case ([]): If the list is empty, return Just [], representing an empty list inside a Maybe.

Recursive Case ((Just x) : xs): If the first element is Just x, then:

Recursively call listMaybe xs to process the remaining list.
If the result of the recursive call is Just res, prepend x to the result list and return Just (x : res).
If the recursive call returns Nothing, propagate Nothing (i.e., return Nothing to indicate a failure).
Handling Nothing (Nothing : xs): If the first element is Nothing, simply skip over it and recursively call listMaybe xs for the rest of the list.

Example:
haskell
Копиране на код
listMaybe [Just 1, Just 2, Just 3] 
-- Output: Just [1, 2, 3]

listMaybe [Just 1, Nothing, Just 3] 
-- Output: Nothing

2. dirs:
haskell
Копиране на код
dirs :: [FileSystem] -> [String]
dirs (Root n _ : xs') = up xs' : dirs xs'
 where up :: [FileSystem] -> String 
       up (Root "/" _ : xss) = "/" ++ up xss
       up (Root n _ : xss) = "/" ++ n ++ up xss
       up _ = "" 
dirs _ = []
Purpose:
This function processes a list of FileSystem items (likely a path or list of directories) and returns a list of directory paths (as String).
Logic:
Base Case (Root n _ : xs'): If the first item is a Root, representing a folder:
The up function processes the remaining list of file systems (xs') recursively to build a directory path.
up constructs paths by:
If the first folder is the root ("/"), it simply appends the path recursively.
For other folders, it adds the folder's name to the path.
Recursively building the full path using / as a separator.
Recursive Case (dirs _ = []): If the list is empty or doesn't contain Root, return an empty list [].
Example:
haskell
Копиране на код
dirs [Root "home" [Root "user" [Root "docs" []]]] 
-- Output: ["/home/user/docs"]

dirs [Root "/" [Root "home" []]]
-- Output: ["/home"]

3. catFiles:
haskell
Копиране на код
catFiles :: String -> FileSystem -> FileSystem -> Maybe FileSystem
catFiles newName (File _ cnt) (File _ cnt') = Just $ File newName (cnt' ++ cnt)
catFiles _ _ _ = Nothing
Purpose:
This function takes two files and combines their contents, returning a new FileSystem representing the concatenated content as a new file.
Logic:
File Concatenation ((File _ cnt) (File _ cnt')): If both inputs are files (File constructors):
The contents (cnt and cnt') of the files are concatenated, and a new File is created with the specified newName and the concatenated contents.
Non-File Cases (_ _ _): If either or both of the arguments are not files, return Nothing.

Example:
haskell
Копиране на код
catFiles "combined.txt" (File "file1.txt" "Hello") (File "file2.txt" " World")
-- Output: Just (File "combined.txt" "Hello World")

4. nameOfRoot:
haskell
Копиране на код
nameOfRoot :: FileSystem -> Maybe String 
nameOfRoot (Root n _) = Just n
nameOfRoot _ = Nothing
Purpose:
This function extracts the name of the root folder from a FileSystem structure.
Logic:
If the input is a Root (representing a root folder), it returns the folder's name (n) wrapped in Just.
If the input is not a Root, it returns Nothing.
Example:
haskell
Копиране на код
nameOfRoot (Root "home" []) 
-- Output: Just "home"

nameOfRoot (File "file.txt" "content") 
-- Output: Nothing

Change

1. changeDir:
haskell
Копиране на код
changeDir :: String -> [FileSystem] -> Maybe FileSystem 
changeDir name xs = headMaybe $ filter (isNameOfFolder name) xs
Purpose:
This function is designed to find a folder by its name within a list of FileSystem items and return it wrapped in Maybe. If the folder is not found, it returns Nothing.
Logic:
filter (isNameOfFolder name) xs:
Filters the list xs by checking each FileSystem item with the predicate isNameOfFolder name. This predicate determines if the current FileSystem item matches the provided folder name name.
headMaybe:
After filtering, headMaybe is applied to the filtered list. headMaybe is a safer version of head, which returns Nothing if the list is empty, or Just the first element of the list if it exists.
Essentially, headMaybe is used here to get the first folder that matches the given name, if any.
Example:
haskell
Копиране на код
changeDir "folder1" [Root "folder1" [], Root "folder2" []]
-- Output: Just (Root "folder1" [])
If no folder is found, the output would be Nothing:

haskell
Копиране на код
changeDir "folder3" [Root "folder1" [], Root "folder2" []]
-- Output: Nothing

2. changeEntity:
haskell
Копиране на код
changeEntity :: FileSystem -> FileSystem -> FileSystem
changeEntity new old@(Root n xs) = 
    case nameOfRoot new of 
        Nothing    -> old
        Just name' -> if name' == n then new else Root n $ changeEntityDeep new xs
    where 
        changeEntityDeep :: FileSystem -> [FileSystem] -> [FileSystem]
        changeEntityDeep new@(Root n xs) (old@(Root n' xss) : xs')
           | n == n'   = new : xs'
           | otherwise = Root n' (changeEntityDeep new xss) : changeEntityDeep new xs'
        changeEntityDeep new (old : xs') = old : changeEntityDeep new xs'
        changeEntityDeep _ x = x
Purpose:
This function updates a FileSystem structure by replacing an existing Root directory with a new one. If the name of the root directory in the new FileSystem matches the old one, it replaces the old root directory with the new one.
The function recursively traverses the FileSystem structure to make the change, handling both the root directory and its subdirectories.
Logic:
case nameOfRoot new of:

The first part of the function checks the root name of the new file system by calling nameOfRoot new.
If nameOfRoot returns Nothing (i.e., the new file system is not a Root), it simply returns the old file system unchanged.
If Just name' is returned (i.e., new has a root name), it checks whether the name matches the root name of the old file system.
If the root names match (name' == n), it replaces the old root directory with the new one, i.e., returns new.

If the root names don't match (name' /= n), it recursively applies changeEntityDeep to the subdirectories (contents) of the root directory.

changeEntityDeep:

This function is responsible for traversing the list of subdirectories (xs) and recursively applying the same change logic.
For each Root subdirectory, it checks if the root names match. If they do, it replaces the subdirectory with the new FileSystem entity.
If the root names don’t match, it keeps the subdirectory unchanged and recursively processes its contents.
Base Case (changeEntityDeep _ x = x):

This handles non-Root file system entities (like files). In this case, it simply returns the entity unchanged.
Example:
haskell
Копиране на код
changeEntity (Root "home" [File "file1" "content"]) (Root "home" [File "file1" "content", Folder "docs" []])
-- Output: Root "home" [File "file1" "content", Folder "docs" []]

changeEntity (Root "home" [File "file1" "new content"]) (Root "work" [File "file1" "content"])
-- Output: Root "work" [File "file1" "content"]

Add

1. add:
haskell
Копиране на код
add :: String -> FileSystem -> Maybe FileSystem -> Maybe FileSystem
add path toAdd (Just old@(Root n xs)) = case getNextDir path of 
    Just ("", "")     -> Just (Root n (toAdd : xs))
    Just (rest, curr) -> case changeDir curr xs of 
        Nothing -> Nothing 
        Just dir@(Root path' files) -> case add rest toAdd (Just dir) of
            Nothing -> Nothing
            Just new@(Root dir xs'') -> Just (changeEntity new old)
    Nothing -> Nothing 
add _ _ _ = Nothing 
Purpose:
The add function inserts a new FileSystem entity (toAdd) into a folder specified by path. It traverses the folder structure to find the target folder where the new entity should be added.
Logic:
Case Just old@(Root n xs):

The first argument, path, is the path where we want to add the toAdd entity.
The second argument is the current FileSystem item (old), which is expected to be a Root folder with a list of contents (xs).
getNextDir path:

The function getNextDir path processes the path string into a tuple ("rest", "curr"). The idea is that rest represents the remaining path and curr represents the folder name at the current level.
Just ("", ""): If the path is empty (""), it means we want to add toAdd to the current folder. Thus, toAdd is added to the xs list, and the updated Root is returned.
Just (rest, curr): If the path is not empty, we need to traverse deeper into the folder structure:
The changeDir curr xs function is called to find the folder matching the name curr in the current folder's contents (xs).
If changeDir curr xs finds the folder (Just dir), we recursively call add rest toAdd (Just dir) to try and add the entity deeper inside.
Once the item is added in the subfolder, the changeEntity function is used to update the parent folder (old) with the modified folder (new).
Nothing -> Nothing: If getNextDir path fails to return valid directory names or if any of the recursive operations fail, Nothing is returned.

Example:
haskell
Копиране на код
-- Suppose the structure is Root "home" [Root "user" [], File "file1" "content"]
add "user/docs" (File "doc.txt" "content") (Just (Root "home" [Root "user" [], File "file1" "content"]))

-- This would try to add "doc.txt" inside "user/docs". If "user" has a "docs" folder, it adds it inside.
2. addFile:
haskell
Копиране на код
addFile :: String -> String -> String -> Maybe FileSystem -> Maybe FileSystem
addFile path name val = add path (File name val)
Purpose:
The addFile function is a convenience function that adds a new file with the given name and val (contents) at the specified path.
Logic:
It simply calls the add function, passing the path and creating a File entity with the specified name and val.
Example:
haskell
Копиране на код
addFile "user/docs" "doc.txt" "Hello World!" (Just (Root "home" [Root "user" [], File "file1" "content"]))
-- This will try to add a file named "doc.txt" with the content "Hello World!" inside the "user/docs" folder.
3. addFolder:
haskell
Копиране на код
addFolder :: String -> String -> Maybe FileSystem -> Maybe FileSystem
addFolder path name = add path (Root name [])
Purpose:
The addFolder function is another convenience function that adds a new folder with the given name at the specified path.
Logic:
It calls the add function, passing the path and creating a new empty folder (Root name []) at that path.
Example:
haskell
Копиране на код
addFolder "user/docs" "newFolder" (Just (Root "home" [Root "user" [], File "file1" "content"]))
-- This will try to add a folder named "newFolder" inside "user/docs".

 Remove

**

